usePrologVariables: true.

% maxTreeDepthInNodes                 = 3
% maxTreeDepthInLiterals              = 12
% maxNumberOfLiteralsAtAnInteriorNode = 1
% maxFreeBridgersInBody               = 1
% maxNumberOfClauses                  = 8
% maxNodesToConsider                  = 10
% maxNodesToCreate                    = 10,000
% maxAcceptableNodeScoreToStop        = 0.003
% negPosRatio                         = 2.000
% testNegPosRatio                     = -1.000
% # of pos examples                   = 15
% # of neg examples                   = 0



%%%%%  WILL-Produced Tree #1 @ 18:59:53 4/20/17.  [Using 3,352,264 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( childof(B, A) )
%   then if ( siblingof(A, C) )
%   | then return 0.20271631169983736;  // std dev = 0.866, 4.000 (wgt'ed) examples reached here.  /* #neg=1 #pos=3 */
%   | else return 0.5248156017661788;  // std dev = 0.816, 3.000 (wgt'ed) examples reached here.  /* #neg=1 #pos=2 */
%   else return -0.1418510649004878;  // std dev = 0.000, 8.000 (wgt'ed) examples reached here.  /* #neg=8 */


% Clauses:

father(A, B, 0.20271631169983736) :- 
     childof(B, A), 
     siblingof(A, C), 
     !. // Clause #1.

father(A, B, 0.5248156017661788) :- 
     childof(B, A), 
     !. // Clause #2.

father(A, B, -0.1418510649004878) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_father(a, b, 0.20271631169983736) :-  /* #neg=1 #pos=3 */ 
   childof(b, a),
   siblingof(a, underscore),
   !. // Flattened version of clause #1.

flattened_father(a, b, 0.5248156017661788) :-  /* #neg=1 #pos=2 */ 
   childof(b, a),
   !. // Flattened version of clause #2.

flattened_father(underscore, underscore, -0.1418510649004878) :-  /* #neg=8 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   childof(b, a)
%   siblingof(a, underscore)

%%%%%  WILL-Produced Tree #2 @ 18:59:53 4/20/17.  [Using 1,516,256 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( childof(B, A) )
%   then return 0.607683784239342;  // std dev = 0.905, 6.000 (wgt'ed) examples reached here.  /* #neg=1 #pos=5 */
%   else return -0.12544463852839138;  // std dev = 0.000, 8.000 (wgt'ed) examples reached here.  /* #neg=8 */


% Clauses:

father(A, B, 0.607683784239342) :- 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.12544463852839138) :- !. // Clause #2.


% The flattened versions of these clauses:

flattened_father(a, b, 0.607683784239342) :-  /* #neg=1 #pos=5 */ 
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, underscore, -0.12544463852839138) :-  /* #neg=8 */ 
   !. // Flattened version of clause #2.


% The unique flattened literals:
%   childof(b, a)

%%%%%  WILL-Produced Tree #3 @ 18:59:53 4/20/17.  [Using 1,517,328 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( childof(B, A) )
%   then if ( siblingof(A, C) )
%   | then return 0.130675244268131;  // std dev = 0.866, 4.000 (wgt'ed) examples reached here.  /* #neg=1 #pos=3 */
%   | else return 0.32760994582032416;  // std dev = 0.816, 3.000 (wgt'ed) examples reached here.  /* #neg=1 #pos=2 */
%   else return -0.11231637819360639;  // std dev = 0.000, 9.000 (wgt'ed) examples reached here.  /* #neg=9 */


% Clauses:

father(A, B, 0.130675244268131) :- 
     childof(B, A), 
     siblingof(A, C), 
     !. // Clause #1.

father(A, B, 0.32760994582032416) :- 
     childof(B, A), 
     !. // Clause #2.

father(A, B, -0.11231637819360639) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_father(a, b, 0.130675244268131) :-  /* #neg=1 #pos=3 */ 
   childof(b, a),
   siblingof(a, underscore),
   !. // Flattened version of clause #1.

flattened_father(a, b, 0.32760994582032416) :-  /* #neg=1 #pos=2 */ 
   childof(b, a),
   !. // Flattened version of clause #2.

flattened_father(underscore, underscore, -0.11231637819360639) :-  /* #neg=9 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   childof(b, a)
%   siblingof(a, underscore)

%%%%%  WILL-Produced Tree #4 @ 18:59:53 4/20/17.  [Using 1,515,112 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( childof(B, A) )
%   then return 0.3993593897526457;  // std dev = 0.894, 6.000 (wgt'ed) examples reached here.  /* #neg=1 #pos=5 */
%   else return -0.10159632948783627;  // std dev = 0.000, 7.000 (wgt'ed) examples reached here.  /* #neg=7 */


% Clauses:

father(A, B, 0.3993593897526457) :- 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.10159632948783627) :- !. // Clause #2.


% The flattened versions of these clauses:

flattened_father(a, b, 0.3993593897526457) :-  /* #neg=1 #pos=5 */ 
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, underscore, -0.10159632948783627) :-  /* #neg=7 */ 
   !. // Flattened version of clause #2.


% The unique flattened literals:
%   childof(b, a)

%%%%%  WILL-Produced Tree #5 @ 18:59:53 4/20/17.  [Using 1,548,272 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( male(B) )
%   then if ( childof(B, A) )
%   | then return 0.4630829502243188;  // std dev = 0.040, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   | else return -0.09269127618926094;  // std dev = 2.63e-09, 3.000 (wgt'ed) examples reached here.  /* #neg=3 */
%   else return -0.2334151176014776;  // std dev = 0.345, 3.000 (wgt'ed) examples reached here.  /* #neg=3 */


% Clauses:

father(A, B, 0.4630829502243188) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.09269127618926094) :- 
     male(B), 
     !. // Clause #2.

father(A, B, -0.2334151176014776) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_father(a, b, 0.4630829502243188) :-  /* #pos=5 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, a, -0.09269127618926094) :-  /* #neg=3 */ 
   male(a),
   !. // Flattened version of clause #2.

flattened_father(underscore, underscore, -0.2334151176014776) :-  /* #neg=3 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   male(b)
%   childof(b, a)
%   male(a)

%%%%%  WILL-Produced Tree #6 @ 18:59:53 4/20/17.  [Using 1,548,440 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( male(B) )
%   then if ( childof(B, A) )
%   | then return 0.35195999953690527;  // std dev = 0.037, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   | else return -0.08518475138839687;  // std dev = 0.000, 5.000 (wgt'ed) examples reached here.  /* #neg=5 */
%   else return -0.21437658766102188;  // std dev = 0.342, 3.000 (wgt'ed) examples reached here.  /* #neg=3 */


% Clauses:

father(A, B, 0.35195999953690527) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.08518475138839687) :- 
     male(B), 
     !. // Clause #2.

father(A, B, -0.21437658766102188) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_father(a, b, 0.35195999953690527) :-  /* #pos=5 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, a, -0.08518475138839687) :-  /* #neg=5 */ 
   male(a),
   !. // Flattened version of clause #2.

flattened_father(underscore, underscore, -0.21437658766102188) :-  /* #neg=3 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   male(b)
%   childof(b, a)
%   male(a)

%%%%%  WILL-Produced Tree #7 @ 18:59:53 4/20/17.  [Using 1,557,080 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( male(B) )
%   then if ( childof(B, A) )
%   | then return 0.2764789098476175;  // std dev = 0.033, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   | else return -0.07877675473109173;  // std dev = 0.000, 5.000 (wgt'ed) examples reached here.  /* #neg=5 */
%   else return -0.1755627970279108;  // std dev = 0.396, 6.000 (wgt'ed) examples reached here.  /* #neg=6 */


% Clauses:

father(A, B, 0.2764789098476175) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.07877675473109173) :- 
     male(B), 
     !. // Clause #2.

father(A, B, -0.1755627970279108) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_father(a, b, 0.2764789098476175) :-  /* #pos=5 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, a, -0.07877675473109173) :-  /* #neg=5 */ 
   male(a),
   !. // Flattened version of clause #2.

flattened_father(underscore, underscore, -0.1755627970279108) :-  /* #neg=6 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   male(b)
%   childof(b, a)
%   male(a)

%%%%%  WILL-Produced Tree #8 @ 18:59:53 4/20/17.  [Using 1,558,544 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( childof(B, A) )
%   then return 0.22474959806960185;  // std dev = 0.028, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   else return -0.06898267308359865;  // std dev = 0.019, 5.000 (wgt'ed) examples reached here.  /* #neg=5 */


% Clauses:

father(A, B, 0.22474959806960185) :- 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.06898267308359865) :- !. // Clause #2.


% The flattened versions of these clauses:

flattened_father(a, b, 0.22474959806960185) :-  /* #pos=5 */ 
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, underscore, -0.06898267308359865) :-  /* #neg=5 */ 
   !. // Flattened version of clause #2.


% The unique flattened literals:
%   childof(b, a)

%%%%%  WILL-Produced Tree #9 @ 18:59:53 4/20/17.  [Using 1,576,344 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( male(B) )
%   then if ( childof(B, A) )
%   | then return 0.1880465729470657;  // std dev = 0.025, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   | else return -0.0686992574352281;  // std dev = 2.63e-09, 6.000 (wgt'ed) examples reached here.  /* #neg=6 */
%   else return -0.2413972213552535;  // std dev = 0.386, 4.000 (wgt'ed) examples reached here.  /* #neg=4 */


% Clauses:

father(A, B, 0.1880465729470657) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.0686992574352281) :- 
     male(B), 
     !. // Clause #2.

father(A, B, -0.2413972213552535) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_father(a, b, 0.1880465729470657) :-  /* #pos=5 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, a, -0.0686992574352281) :-  /* #neg=6 */ 
   male(a),
   !. // Flattened version of clause #2.

flattened_father(underscore, underscore, -0.2413972213552535) :-  /* #neg=4 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   male(b)
%   childof(b, a)
%   male(a)

%%%%%  WILL-Produced Tree #10 @ 18:59:54 4/20/17.  [Using 1,581,128 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( male(B) )
%   then if ( childof(B, A) )
%   | then return 0.1610203449142241;  // std dev = 0.022, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   | else return -0.06443201829076294;  // std dev = 0.000, 8.000 (wgt'ed) examples reached here.  /* #neg=8 */
%   else return -0.1987085606232052;  // std dev = 0.320, 4.000 (wgt'ed) examples reached here.  /* #neg=4 */


% Clauses:

father(A, B, 0.1610203449142241) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.06443201829076294) :- 
     male(B), 
     !. // Clause #2.

father(A, B, -0.1987085606232052) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_father(a, b, 0.1610203449142241) :-  /* #pos=5 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, a, -0.06443201829076294) :-  /* #neg=8 */ 
   male(a),
   !. // Flattened version of clause #2.

flattened_father(underscore, underscore, -0.1987085606232052) :-  /* #neg=4 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   male(b)
%   childof(b, a)
%   male(a)

%%%%%  WILL-Produced Tree Combined @ 18:59:54 4/20/17.  [Using 1,596,168 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( male(B) )
%   then if ( childof(B, A) )
%   | then return 0.140448940251206;  // std dev = 0.020, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   | else return -0.060655319602823755;  // std dev = 0.000, 6.000 (wgt'ed) examples reached here.  /* #neg=6 */
%   else return -0.13152359268082733;  // std dev = 0.346, 6.000 (wgt'ed) examples reached here.  /* #neg=6 */


% Clauses:

father(A, B, 0.140448940251206) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.060655319602823755) :- 
     male(B), 
     !. // Clause #2.

father(A, B, -0.13152359268082733) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_father(a, b, 0.140448940251206) :-  /* #pos=5 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, a, -0.060655319602823755) :-  /* #neg=6 */ 
   male(a),
   !. // Flattened version of clause #2.

flattened_father(underscore, underscore, -0.13152359268082733) :-  /* #neg=6 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   male(b)
%   childof(b, a)
%   male(a)

%%%%%  WILL-Produced Tree #12 @ 18:59:54 4/20/17.  [Using 1,596,936 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( male(B) )
%   then if ( childof(B, A) )
%   | then return 0.1243431644607172;  // std dev = 0.018, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   | else return -0.05729011643686004;  // std dev = 1.86e-09, 8.000 (wgt'ed) examples reached here.  /* #neg=8 */
%   else return -0.13156958528945525;  // std dev = 0.283, 5.000 (wgt'ed) examples reached here.  /* #neg=5 */


% Clauses:

father(A, B, 0.1243431644607172) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.05729011643686004) :- 
     male(B), 
     !. // Clause #2.

father(A, B, -0.13156958528945525) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_father(a, b, 0.1243431644607172) :-  /* #pos=5 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, a, -0.05729011643686004) :-  /* #neg=8 */ 
   male(a),
   !. // Flattened version of clause #2.

flattened_father(underscore, underscore, -0.13156958528945525) :-  /* #neg=5 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   male(b)
%   childof(b, a)
%   male(a)

%%%%%  WILL-Produced Tree #13 @ 18:59:54 4/20/17.  [Using 1,607,632 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( male(B) )
%   then if ( childof(B, A) )
%   | then return 0.11143135254544242;  // std dev = 0.016, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   | else return -0.05427333362515563;  // std dev = 0.000, 6.000 (wgt'ed) examples reached here.  /* #neg=6 */
%   else return -0.10826445048248905;  // std dev = 0.290, 6.000 (wgt'ed) examples reached here.  /* #neg=6 */


% Clauses:

father(A, B, 0.11143135254544242) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.05427333362515563) :- 
     male(B), 
     !. // Clause #2.

father(A, B, -0.10826445048248905) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_father(a, b, 0.11143135254544242) :-  /* #pos=5 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, a, -0.05427333362515563) :-  /* #neg=6 */ 
   male(a),
   !. // Flattened version of clause #2.

flattened_father(underscore, underscore, -0.10826445048248905) :-  /* #neg=6 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   male(b)
%   childof(b, a)
%   male(a)

%%%%%  WILL-Produced Tree #14 @ 18:59:54 4/20/17.  [Using 1,606,968 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( childof(B, A) )
%   then return 0.043996358530551914;  // std dev = 0.312, 6.000 (wgt'ed) examples reached here.  /* #neg=1 #pos=5 */
%   else return -0.045684129814826994;  // std dev = 0.037, 10.000 (wgt'ed) examples reached here.  /* #neg=10 */


% Clauses:

father(A, B, 0.043996358530551914) :- 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.045684129814826994) :- !. // Clause #2.


% The flattened versions of these clauses:

flattened_father(a, b, 0.043996358530551914) :-  /* #neg=1 #pos=5 */ 
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, underscore, -0.045684129814826994) :-  /* #neg=10 */ 
   !. // Flattened version of clause #2.


% The unique flattened literals:
%   childof(b, a)

%%%%%  WILL-Produced Tree #15 @ 18:59:54 4/20/17.  [Using 1,642,128 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( male(B) )
%   then if ( childof(B, A) )
%   | then return 0.09695255178536352;  // std dev = 0.014, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   | else return -0.04936549131985763;  // std dev = 0.000, 7.000 (wgt'ed) examples reached here.  /* #neg=7 */
%   else return -0.11786282194828561;  // std dev = 0.265, 5.000 (wgt'ed) examples reached here.  /* #neg=5 */


% Clauses:

father(A, B, 0.09695255178536352) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.04936549131985763) :- 
     male(B), 
     !. // Clause #2.

father(A, B, -0.11786282194828561) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_father(a, b, 0.09695255178536352) :-  /* #pos=5 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, a, -0.04936549131985763) :-  /* #neg=7 */ 
   male(a),
   !. // Flattened version of clause #2.

flattened_father(underscore, underscore, -0.11786282194828561) :-  /* #neg=5 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   male(b)
%   childof(b, a)
%   male(a)

%%%%%  WILL-Produced Tree #16 @ 18:59:54 4/20/17.  [Using 1,651,360 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( male(B) )
%   then if ( childof(B, A) )
%   | then return 0.0887930019536239;  // std dev = 0.013, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   | else return -0.04709970523221906;  // std dev = 0.000, 4.000 (wgt'ed) examples reached here.  /* #neg=4 */
%   else return -0.09732109936192075;  // std dev = 0.192, 3.000 (wgt'ed) examples reached here.  /* #neg=3 */


% Clauses:

father(A, B, 0.0887930019536239) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.04709970523221906) :- 
     male(B), 
     !. // Clause #2.

father(A, B, -0.09732109936192075) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_father(a, b, 0.0887930019536239) :-  /* #pos=5 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, a, -0.04709970523221906) :-  /* #neg=4 */ 
   male(a),
   !. // Flattened version of clause #2.

flattened_father(underscore, underscore, -0.09732109936192075) :-  /* #neg=3 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   male(b)
%   childof(b, a)
%   male(a)

%%%%%  WILL-Produced Tree #17 @ 18:59:54 4/20/17.  [Using 2,303,704 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( male(B) )
%   then if ( childof(B, A) )
%   | then return 0.08186911349878896;  // std dev = 0.012, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   | else return -0.04503033343244013;  // std dev = 0.000, 4.000 (wgt'ed) examples reached here.  /* #neg=4 */
%   else if ( childof(B, A) )
%   | then return -0.21905602935920618;  // std dev = 0.021, 3.000 (wgt'ed) examples reached here.  /* #neg=3 */
%   | else return -0.017193564227677975;  // std dev = 0.000, 5.000 (wgt'ed) examples reached here.  /* #neg=5 */


% Clauses:

father(A, B, 0.08186911349878896) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.04503033343244013) :- 
     male(B), 
     !. // Clause #2.

father(A, B, -0.21905602935920618) :- 
     childof(B, A), 
     !. // Clause #3.

father(A, B, -0.017193564227677975) :- !. // Clause #4.


% The flattened versions of these clauses:

flattened_father(a, b, 0.08186911349878896) :-  /* #pos=5 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, a, -0.04503033343244013) :-  /* #neg=4 */ 
   male(a),
   !. // Flattened version of clause #2.

flattened_father(a, b, -0.21905602935920618) :-  /* #neg=3 */ 
   childof(b, a),
   !. // Flattened version of clause #3.

flattened_father(underscore, underscore, -0.017193564227677975) :-  /* #neg=5 */ 
   !. // Flattened version of clause #4.


% The unique flattened literals:
%   male(b)
%   childof(b, a)
%   male(a)

%%%%%  WILL-Produced Tree #18 @ 18:59:54 4/20/17.  [Using 1,645,504 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( male(B) )
%   then if ( childof(B, A) )
%   | then return 0.07592442499661203;  // std dev = 0.011, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   | else return -0.04313310189137581;  // std dev = 0.000, 5.000 (wgt'ed) examples reached here.  /* #neg=5 */
%   else return -0.07382478490199328;  // std dev = 0.198, 6.000 (wgt'ed) examples reached here.  /* #neg=6 */


% Clauses:

father(A, B, 0.07592442499661203) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.04313310189137581) :- 
     male(B), 
     !. // Clause #2.

father(A, B, -0.07382478490199328) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_father(a, b, 0.07592442499661203) :-  /* #pos=5 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, a, -0.04313310189137581) :-  /* #neg=5 */ 
   male(a),
   !. // Flattened version of clause #2.

flattened_father(underscore, underscore, -0.07382478490199328) :-  /* #neg=6 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   male(b)
%   childof(b, a)
%   male(a)

%%%%%  WILL-Produced Tree #19 @ 18:59:54 4/20/17.  [Using 1,651,328 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( male(B) )
%   then if ( childof(B, A) )
%   | then return 0.07076795454698179;  // std dev = 0.011, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   | else return -0.04138755356200692;  // std dev = 1.32e-09, 5.000 (wgt'ed) examples reached here.  /* #neg=5 */
%   else return -0.058643788981936174;  // std dev = 0.149, 4.000 (wgt'ed) examples reached here.  /* #neg=4 */


% Clauses:

father(A, B, 0.07076795454698179) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.04138755356200692) :- 
     male(B), 
     !. // Clause #2.

father(A, B, -0.058643788981936174) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_father(a, b, 0.07076795454698179) :-  /* #pos=5 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, a, -0.04138755356200692) :-  /* #neg=5 */ 
   male(a),
   !. // Flattened version of clause #2.

flattened_father(underscore, underscore, -0.058643788981936174) :-  /* #neg=4 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   male(b)
%   childof(b, a)
%   male(a)

%%%%%  WILL-Produced Tree #20 @ 18:59:55 4/20/17.  [Using 1,666,960 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( male(B) )
%   then if ( childof(B, A) )
%   | then return 0.06625478225950823;  // std dev = 0.010, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   | else return -0.039776330305823365;  // std dev = 0.000, 5.000 (wgt'ed) examples reached here.  /* #neg=5 */
%   else return -0.04760005289654912;  // std dev = 0.147, 5.000 (wgt'ed) examples reached here.  /* #neg=5 */


% Clauses:

father(A, B, 0.06625478225950823) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.039776330305823365) :- 
     male(B), 
     !. // Clause #2.

father(A, B, -0.04760005289654912) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_father(a, b, 0.06625478225950823) :-  /* #pos=5 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, a, -0.039776330305823365) :-  /* #neg=5 */ 
   male(a),
   !. // Flattened version of clause #2.

flattened_father(underscore, underscore, -0.04760005289654912) :-  /* #neg=5 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   male(b)
%   childof(b, a)
%   male(a)

%%%%%  WILL-Produced Tree #21 @ 18:59:55 4/20/17.  [Using 1,707,792 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( male(B) )
%   then if ( childof(B, A) )
%   | then return 0.06227308861256886;  // std dev = 0.010, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   | else return -0.038284610342189905;  // std dev = 0.000, 6.000 (wgt'ed) examples reached here.  /* #neg=6 */
%   else return -0.06335934109039389;  // std dev = 0.171, 6.000 (wgt'ed) examples reached here.  /* #neg=6 */


% Clauses:

father(A, B, 0.06227308861256886) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.038284610342189905) :- 
     male(B), 
     !. // Clause #2.

father(A, B, -0.06335934109039389) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_father(a, b, 0.06227308861256886) :-  /* #pos=5 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, a, -0.038284610342189905) :-  /* #neg=6 */ 
   male(a),
   !. // Flattened version of clause #2.

flattened_father(underscore, underscore, -0.06335934109039389) :-  /* #neg=6 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   male(b)
%   childof(b, a)
%   male(a)

%%%%%  WILL-Produced Tree #22 @ 18:59:55 4/20/17.  [Using 1,684,712 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( childof(B, A) )
%   then return 0.05873529850686068;  // std dev = 0.009, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   else return -0.029820171613915612;  // std dev = 0.034, 10.000 (wgt'ed) examples reached here.  /* #neg=10 */


% Clauses:

father(A, B, 0.05873529850686068) :- 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.029820171613915612) :- !. // Clause #2.


% The flattened versions of these clauses:

flattened_father(a, b, 0.05873529850686068) :-  /* #pos=5 */ 
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, underscore, -0.029820171613915612) :-  /* #neg=10 */ 
   !. // Flattened version of clause #2.


% The unique flattened literals:
%   childof(b, a)

%%%%%  WILL-Produced Tree #23 @ 18:59:55 4/20/17.  [Using 1,717,112 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( male(B) )
%   then if ( childof(B, A) )
%   | then return 0.05557190190618233;  // std dev = 0.009, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   | else return -0.03585442378390482;  // std dev = 0.000, 5.000 (wgt'ed) examples reached here.  /* #neg=5 */
%   else return -0.08702496752857874;  // std dev = 0.149, 4.000 (wgt'ed) examples reached here.  /* #neg=4 */


% Clauses:

father(A, B, 0.05557190190618233) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.03585442378390482) :- 
     male(B), 
     !. // Clause #2.

father(A, B, -0.08702496752857874) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_father(a, b, 0.05557190190618233) :-  /* #pos=5 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, a, -0.03585442378390482) :-  /* #neg=5 */ 
   male(a),
   !. // Flattened version of clause #2.

flattened_father(underscore, underscore, -0.08702496752857874) :-  /* #neg=4 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   male(b)
%   childof(b, a)
%   male(a)

%%%%%  WILL-Produced Tree #24 @ 18:59:55 4/20/17.  [Using 1,684,992 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( childof(B, A) )
%   then return 0.02055106406959724;  // std dev = 0.176, 6.000 (wgt'ed) examples reached here.  /* #neg=1 #pos=5 */
%   else return -0.026350489740000867;  // std dev = 0.036, 11.000 (wgt'ed) examples reached here.  /* #neg=11 */


% Clauses:

father(A, B, 0.02055106406959724) :- 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.026350489740000867) :- !. // Clause #2.


% The flattened versions of these clauses:

flattened_father(a, b, 0.02055106406959724) :-  /* #neg=1 #pos=5 */ 
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, underscore, -0.026350489740000867) :-  /* #neg=11 */ 
   !. // Flattened version of clause #2.


% The unique flattened literals:
%   childof(b, a)

%%%%%  WILL-Produced Tree #25 @ 18:59:55 4/20/17.  [Using 1,689,592 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( childof(B, A) )
%   then return 0.019287458007181405;  // std dev = 0.178, 6.000 (wgt'ed) examples reached here.  /* #neg=1 #pos=5 */
%   else return -0.029725462663358716;  // std dev = 0.028, 11.000 (wgt'ed) examples reached here.  /* #neg=11 */


% Clauses:

father(A, B, 0.019287458007181405) :- 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.029725462663358716) :- !. // Clause #2.


% The flattened versions of these clauses:

flattened_father(a, b, 0.019287458007181405) :-  /* #neg=1 #pos=5 */ 
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, underscore, -0.029725462663358716) :-  /* #neg=11 */ 
   !. // Flattened version of clause #2.


% The unique flattened literals:
%   childof(b, a)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%  Final call for computing score for father.  %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

stepLength_tree1(1.0).
stepLength_tree2(1.0).
stepLength_tree3(1.0).
stepLength_tree4(1.0).
stepLength_tree5(1.0).
stepLength_tree6(1.0).
stepLength_tree7(1.0).
stepLength_tree8(1.0).
stepLength_tree9(1.0).
stepLength_tree10(1.0).
stepLength_tree11(1.0).
stepLength_tree12(1.0).
stepLength_tree13(1.0).
stepLength_tree14(1.0).
stepLength_tree15(1.0).
stepLength_tree16(1.0).
stepLength_tree17(1.0).
stepLength_tree18(1.0).
stepLength_tree19(1.0).
stepLength_tree20(1.0).
stepLength_tree21(1.0).
stepLength_tree22(1.0).
stepLength_tree23(1.0).
stepLength_tree24(1.0).
stepLength_tree25(1.0).

logPrior(-1.8).
father(D, E, Total) :- // A general accessor. 
   father(D, E, 1000000, Total), !.
father(D, E, Total) :- waitHere("This should not fail", father(D, E, Total)).

father(D, E, TreesToUse, Total) :- // A tree-limited accessor (e.g., for tuning the number of trees to use).
   logPrior(LogPrior),
   getScore_father_tree1(D, E, TreesToUse, Total1),
   getScore_father_tree2(D, E, TreesToUse, Total2),
   getScore_father_tree3(D, E, TreesToUse, Total3),
   getScore_father_tree4(D, E, TreesToUse, Total4),
   getScore_father_tree5(D, E, TreesToUse, Total5),
   getScore_father_tree6(D, E, TreesToUse, Total6),
   getScore_father_tree7(D, E, TreesToUse, Total7),
   getScore_father_tree8(D, E, TreesToUse, Total8),
   getScore_father_tree9(D, E, TreesToUse, Total9),
   getScore_father_tree10(D, E, TreesToUse, Total10),
   getScore_father_tree11(D, E, TreesToUse, Total11),
   getScore_father_tree12(D, E, TreesToUse, Total12),
   getScore_father_tree13(D, E, TreesToUse, Total13),
   getScore_father_tree14(D, E, TreesToUse, Total14),
   getScore_father_tree15(D, E, TreesToUse, Total15),
   getScore_father_tree16(D, E, TreesToUse, Total16),
   getScore_father_tree17(D, E, TreesToUse, Total17),
   getScore_father_tree18(D, E, TreesToUse, Total18),
   getScore_father_tree19(D, E, TreesToUse, Total19),
   getScore_father_tree20(D, E, TreesToUse, Total20),
   getScore_father_tree21(D, E, TreesToUse, Total21),
   getScore_father_tree22(D, E, TreesToUse, Total22),
   getScore_father_tree23(D, E, TreesToUse, Total23),
   getScore_father_tree24(D, E, TreesToUse, Total24),
   getScore_father_tree25(D, E, TreesToUse, Total25),
   Total is LogPrior + Total1 + Total2 + Total3 + Total4 + Total5 + Total6 + Total7 + Total8 + Total9 + Total10 + Total11 + Total12 + Total13 + Total14 + Total15 + Total16 + Total17 + Total18 + Total19 + Total20 + Total21 + Total22 + Total23 + Total24 + Total25,
   !.
father(D, E, TreesToUse, Total) :- waitHere("This should not fail", father(D, E, TreesToUse, Total)).

getScore_father_tree1(D, E, TreesToUse, 0.0) :- 1 > TreesToUse, !.
getScore_father_tree1(D, E, TreesToUse, Total1) :- father_tree1(D, E, Total), stepLength_tree1(StepLen), Total1 is Total * StepLen.

getScore_father_tree2(D, E, TreesToUse, 0.0) :- 2 > TreesToUse, !.
getScore_father_tree2(D, E, TreesToUse, Total2) :- father_tree2(D, E, Total), stepLength_tree2(StepLen), Total2 is Total * StepLen.

getScore_father_tree3(D, E, TreesToUse, 0.0) :- 3 > TreesToUse, !.
getScore_father_tree3(D, E, TreesToUse, Total3) :- father_tree3(D, E, Total), stepLength_tree3(StepLen), Total3 is Total * StepLen.

getScore_father_tree4(D, E, TreesToUse, 0.0) :- 4 > TreesToUse, !.
getScore_father_tree4(D, E, TreesToUse, Total4) :- father_tree4(D, E, Total), stepLength_tree4(StepLen), Total4 is Total * StepLen.

getScore_father_tree5(D, E, TreesToUse, 0.0) :- 5 > TreesToUse, !.
getScore_father_tree5(D, E, TreesToUse, Total5) :- father_tree5(D, E, Total), stepLength_tree5(StepLen), Total5 is Total * StepLen.

getScore_father_tree6(D, E, TreesToUse, 0.0) :- 6 > TreesToUse, !.
getScore_father_tree6(D, E, TreesToUse, Total6) :- father_tree6(D, E, Total), stepLength_tree6(StepLen), Total6 is Total * StepLen.

getScore_father_tree7(D, E, TreesToUse, 0.0) :- 7 > TreesToUse, !.
getScore_father_tree7(D, E, TreesToUse, Total7) :- father_tree7(D, E, Total), stepLength_tree7(StepLen), Total7 is Total * StepLen.

getScore_father_tree8(D, E, TreesToUse, 0.0) :- 8 > TreesToUse, !.
getScore_father_tree8(D, E, TreesToUse, Total8) :- father_tree8(D, E, Total), stepLength_tree8(StepLen), Total8 is Total * StepLen.

getScore_father_tree9(D, E, TreesToUse, 0.0) :- 9 > TreesToUse, !.
getScore_father_tree9(D, E, TreesToUse, Total9) :- father_tree9(D, E, Total), stepLength_tree9(StepLen), Total9 is Total * StepLen.

getScore_father_tree10(D, E, TreesToUse, 0.0) :- 10 > TreesToUse, !.
getScore_father_tree10(D, E, TreesToUse, Total10) :- father_tree10(D, E, Total), stepLength_tree10(StepLen), Total10 is Total * StepLen.

getScore_father_tree11(D, E, TreesToUse, 0.0) :- 11 > TreesToUse, !.
getScore_father_tree11(D, E, TreesToUse, Total11) :- father_tree11(D, E, Total), stepLength_tree11(StepLen), Total11 is Total * StepLen.

getScore_father_tree12(D, E, TreesToUse, 0.0) :- 12 > TreesToUse, !.
getScore_father_tree12(D, E, TreesToUse, Total12) :- father_tree12(D, E, Total), stepLength_tree12(StepLen), Total12 is Total * StepLen.

getScore_father_tree13(D, E, TreesToUse, 0.0) :- 13 > TreesToUse, !.
getScore_father_tree13(D, E, TreesToUse, Total13) :- father_tree13(D, E, Total), stepLength_tree13(StepLen), Total13 is Total * StepLen.

getScore_father_tree14(D, E, TreesToUse, 0.0) :- 14 > TreesToUse, !.
getScore_father_tree14(D, E, TreesToUse, Total14) :- father_tree14(D, E, Total), stepLength_tree14(StepLen), Total14 is Total * StepLen.

getScore_father_tree15(D, E, TreesToUse, 0.0) :- 15 > TreesToUse, !.
getScore_father_tree15(D, E, TreesToUse, Total15) :- father_tree15(D, E, Total), stepLength_tree15(StepLen), Total15 is Total * StepLen.

getScore_father_tree16(D, E, TreesToUse, 0.0) :- 16 > TreesToUse, !.
getScore_father_tree16(D, E, TreesToUse, Total16) :- father_tree16(D, E, Total), stepLength_tree16(StepLen), Total16 is Total * StepLen.

getScore_father_tree17(D, E, TreesToUse, 0.0) :- 17 > TreesToUse, !.
getScore_father_tree17(D, E, TreesToUse, Total17) :- father_tree17(D, E, Total), stepLength_tree17(StepLen), Total17 is Total * StepLen.

getScore_father_tree18(D, E, TreesToUse, 0.0) :- 18 > TreesToUse, !.
getScore_father_tree18(D, E, TreesToUse, Total18) :- father_tree18(D, E, Total), stepLength_tree18(StepLen), Total18 is Total * StepLen.

getScore_father_tree19(D, E, TreesToUse, 0.0) :- 19 > TreesToUse, !.
getScore_father_tree19(D, E, TreesToUse, Total19) :- father_tree19(D, E, Total), stepLength_tree19(StepLen), Total19 is Total * StepLen.

getScore_father_tree20(D, E, TreesToUse, 0.0) :- 20 > TreesToUse, !.
getScore_father_tree20(D, E, TreesToUse, Total20) :- father_tree20(D, E, Total), stepLength_tree20(StepLen), Total20 is Total * StepLen.

getScore_father_tree21(D, E, TreesToUse, 0.0) :- 21 > TreesToUse, !.
getScore_father_tree21(D, E, TreesToUse, Total21) :- father_tree21(D, E, Total), stepLength_tree21(StepLen), Total21 is Total * StepLen.

getScore_father_tree22(D, E, TreesToUse, 0.0) :- 22 > TreesToUse, !.
getScore_father_tree22(D, E, TreesToUse, Total22) :- father_tree22(D, E, Total), stepLength_tree22(StepLen), Total22 is Total * StepLen.

getScore_father_tree23(D, E, TreesToUse, 0.0) :- 23 > TreesToUse, !.
getScore_father_tree23(D, E, TreesToUse, Total23) :- father_tree23(D, E, Total), stepLength_tree23(StepLen), Total23 is Total * StepLen.

getScore_father_tree24(D, E, TreesToUse, 0.0) :- 24 > TreesToUse, !.
getScore_father_tree24(D, E, TreesToUse, Total24) :- father_tree24(D, E, Total), stepLength_tree24(StepLen), Total24 is Total * StepLen.

getScore_father_tree25(D, E, TreesToUse, 0.0) :- 25 > TreesToUse, !.
getScore_father_tree25(D, E, TreesToUse, Total25) :- father_tree25(D, E, Total), stepLength_tree25(StepLen), Total25 is Total * StepLen.

flattenedLiteralsInThisSetOfTrees(father, 4, [
   male(b),
   male(a),
   childof(b, a),
   siblingof(a, underscore)]).

%%%%%  WILL-Produced Tree Combined @ 18:59:55 4/20/17.  [Using 1,790,520 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( male(B) )
%   then if ( childof(B, A) )
%   | then return 5.7470477203561865;  // std dev = 0.199, 125.000 (wgt'ed) examples reached here.  /* #pos=125 */
%   | else if ( siblingof(A, C) )
%   | | then return -0.2264615884183298;  // std dev = 0.000, 9.000 (wgt'ed) examples reached here.  /* #neg=9 */
%   | | else return -0.6533973420650724;  // std dev = 0.051, 32.000 (wgt'ed) examples reached here.  /* #neg=32 */
%   else if ( childof(B, A) )
%   | then return -3.5231454398669264;  // std dev = 0.265, 25.000 (wgt'ed) examples reached here.  /* #neg=25 */
%   | else return -0.608524994282788;  // std dev = 0.046, 51.000 (wgt'ed) examples reached here.  /* #neg=51 */


% Clauses:

father(A, B, 5.7470477203561865) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.2264615884183298) :- 
     male(B), 
     siblingof(A, C), 
     !. // Clause #2.

father(A, B, -0.6533973420650724) :- 
     male(B), 
     !. // Clause #3.

father(A, B, -3.5231454398669264) :- 
     childof(B, A), 
     !. // Clause #4.

father(A, B, -0.608524994282788) :- !. // Clause #5.


% The flattened versions of these clauses:

flattened_father(a, b, 5.7470477203561865) :-  /* #pos=125 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(a, b, -0.2264615884183298) :-  /* #neg=9 */ 
   male(b),
   siblingof(a, underscore),
   !. // Flattened version of clause #2.

flattened_father(underscore, a, -0.6533973420650724) :-  /* #neg=32 */ 
   male(a),
   !. // Flattened version of clause #3.

flattened_father(a, b, -3.5231454398669264) :-  /* #neg=25 */ 
   childof(b, a),
   !. // Flattened version of clause #4.

flattened_father(underscore, underscore, -0.608524994282788) :-  /* #neg=51 */ 
   !. // Flattened version of clause #5.


% The unique flattened literals:
%   male(b)
%   male(a)
%   childof(b, a)
%   siblingof(a, underscore)
