usePrologVariables: true.

% maxTreeDepthInNodes                 = 3
% maxTreeDepthInLiterals              = 12
% maxNumberOfLiteralsAtAnInteriorNode = 1
% maxFreeBridgersInBody               = 1
% maxNumberOfClauses                  = 8
% maxNodesToConsider                  = 10
% maxNodesToCreate                    = 10,000
% maxAcceptableNodeScoreToStop        = 0.003
% negPosRatio                         = 2.000
% testNegPosRatio                     = -1.000
% # of pos examples                   = 16
% # of neg examples                   = 0



%%%%%  WILL-Produced Tree #1 @ 12:29:19 4/20/17.  [Using 3,310,120 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( childof(B, A) )
%   then return 0.6914822684328455;  // std dev = 0.913, 6.000 (wgt'ed) examples reached here.  /* #neg=1 #pos=5 */
%   else return -0.1418510649004878;  // std dev = 0.000, 10.000 (wgt'ed) examples reached here.  /* #neg=10 */


% Clauses:

father(A, B, 0.6914822684328455) :- 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.1418510649004878) :- !. // Clause #2.


% The flattened versions of these clauses:

flattened_father(a, b, 0.6914822684328455) :-  /* #neg=1 #pos=5 */ 
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, underscore, -0.1418510649004878) :-  /* #neg=10 */ 
   !. // Flattened version of clause #2.


% The unique flattened literals:
%   childof(b, a)

%%%%%  WILL-Produced Tree #2 @ 12:29:19 4/20/17.  [Using 1,506,424 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( childof(B, A) )
%   then if ( male(B) )
%   | then return 0.7518526675222027;  // std dev = 0.000, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   | else return -0.2481473324777973;  // std dev = 0.000, 3.000 (wgt'ed) examples reached here.  /* #neg=3 */
%   else return -0.12544463852839138;  // std dev = 0.000, 9.000 (wgt'ed) examples reached here.  /* #neg=9 */


% Clauses:

father(A, B, 0.7518526675222027) :- 
     childof(B, A), 
     male(B), 
     !. // Clause #1.

father(A, B, -0.2481473324777973) :- 
     childof(B, A), 
     !. // Clause #2.

father(A, B, -0.12544463852839138) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_father(a, b, 0.7518526675222027) :-  /* #pos=5 */ 
   childof(b, a),
   male(b),
   !. // Flattened version of clause #1.

flattened_father(a, b, -0.2481473324777973) :-  /* #neg=3 */ 
   childof(b, a),
   !. // Flattened version of clause #2.

flattened_father(underscore, underscore, -0.12544463852839138) :-  /* #neg=9 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   childof(b, a)
%   male(b)

%%%%%  WILL-Produced Tree #3 @ 12:29:19 4/20/17.  [Using 1,461,000 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( childof(B, A) )
%   then return 0.4560636089862555;  // std dev = 0.724, 6.000 (wgt'ed) examples reached here.  /* #neg=1 #pos=5 */
%   else return -0.11231637819360638;  // std dev = 0.000, 10.000 (wgt'ed) examples reached here.  /* #neg=10 */


% Clauses:

father(A, B, 0.4560636089862555) :- 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.11231637819360638) :- !. // Clause #2.


% The flattened versions of these clauses:

flattened_father(a, b, 0.4560636089862555) :-  /* #neg=1 #pos=5 */ 
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, underscore, -0.11231637819360638) :-  /* #neg=10 */ 
   !. // Flattened version of clause #2.


% The unique flattened literals:
%   childof(b, a)

%%%%%  WILL-Produced Tree #4 @ 12:29:19 4/20/17.  [Using 1,492,760 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( childof(B, A) )
%   then if ( siblingof(A, C) )
%   | then return 0.28414637397335996;  // std dev = 0.662, 4.000 (wgt'ed) examples reached here.  /* #neg=1 #pos=3 */
%   | else return 0.22047156421419012;  // std dev = 0.624, 3.000 (wgt'ed) examples reached here.  /* #neg=1 #pos=2 */
%   else return -0.1015963294878363;  // std dev = 0.000, 13.000 (wgt'ed) examples reached here.  /* #neg=13 */


% Clauses:

father(A, B, 0.28414637397335996) :- 
     childof(B, A), 
     siblingof(A, C), 
     !. // Clause #1.

father(A, B, 0.22047156421419012) :- 
     childof(B, A), 
     !. // Clause #2.

father(A, B, -0.1015963294878363) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_father(a, b, 0.28414637397335996) :-  /* #neg=1 #pos=3 */ 
   childof(b, a),
   siblingof(a, underscore),
   !. // Flattened version of clause #1.

flattened_father(a, b, 0.22047156421419012) :-  /* #neg=1 #pos=2 */ 
   childof(b, a),
   !. // Flattened version of clause #2.

flattened_father(underscore, underscore, -0.1015963294878363) :-  /* #neg=13 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   siblingof(a, underscore)
%   childof(b, a)

%%%%%  WILL-Produced Tree #5 @ 12:29:19 4/20/17.  [Using 1,504,200 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( male(B) )
%   then if ( childof(B, A) )
%   | then return 0.4114462760560114;  // std dev = 0.017, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   | else return -0.09269127618926096;  // std dev = 0.000, 5.000 (wgt'ed) examples reached here.  /* #neg=5 */
%   else return -0.17626425571367568;  // std dev = 0.290, 6.000 (wgt'ed) examples reached here.  /* #neg=6 */


% Clauses:

father(A, B, 0.4114462760560114) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.09269127618926096) :- 
     male(B), 
     !. // Clause #2.

father(A, B, -0.17626425571367568) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_father(a, b, 0.4114462760560114) :-  /* #pos=5 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, a, -0.09269127618926096) :-  /* #neg=5 */ 
   male(a),
   !. // Flattened version of clause #2.

flattened_father(underscore, underscore, -0.17626425571367568) :-  /* #neg=6 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   male(b)
%   childof(b, a)
%   male(a)

%%%%%  WILL-Produced Tree #6 @ 12:29:20 4/20/17.  [Using 1,517,312 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( male(B) )
%   then if ( childof(B, A) )
%   | then return 0.31662115034450283;  // std dev = 0.015, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   | else return -0.08518475138839687;  // std dev = 2.63e-09, 7.000 (wgt'ed) examples reached here.  /* #neg=7 */
%   else if ( male(A) )
%   | then return -0.07889380203092126;  // std dev = 0.000, 3.000 (wgt'ed) examples reached here.  /* #neg=3 */
%   | else return -0.1918664848705507;  // std dev = 0.226, 4.000 (wgt'ed) examples reached here.  /* #neg=4 */


% Clauses:

father(A, B, 0.31662115034450283) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.08518475138839687) :- 
     male(B), 
     !. // Clause #2.

father(A, B, -0.07889380203092126) :- 
     male(A), 
     !. // Clause #3.

father(A, B, -0.1918664848705507) :- !. // Clause #4.


% The flattened versions of these clauses:

flattened_father(a, b, 0.31662115034450283) :-  /* #pos=5 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, a, -0.08518475138839687) :-  /* #neg=7 */ 
   male(a),
   !. // Flattened version of clause #2.

flattened_father(a, underscore, -0.07889380203092126) :-  /* #neg=3 */ 
   male(a),
   !. // Flattened version of clause #3.

flattened_father(underscore, underscore, -0.1918664848705507) :-  /* #neg=4 */ 
   !. // Flattened version of clause #4.


% The unique flattened literals:
%   male(b)
%   childof(b, a)
%   male(a)

%%%%%  WILL-Produced Tree #7 @ 12:29:20 4/20/17.  [Using 1,519,008 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( childof(B, A) )
%   then return 0.1670657844303416;  // std dev = 0.468, 6.000 (wgt'ed) examples reached here.  /* #neg=1 #pos=5 */
%   else return -0.07696098522861775;  // std dev = 0.013, 13.000 (wgt'ed) examples reached here.  /* #neg=13 */


% Clauses:

father(A, B, 0.1670657844303416) :- 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.07696098522861775) :- !. // Clause #2.


% The flattened versions of these clauses:

flattened_father(a, b, 0.1670657844303416) :-  /* #neg=1 #pos=5 */ 
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, underscore, -0.07696098522861775) :-  /* #neg=13 */ 
   !. // Flattened version of clause #2.


% The unique flattened literals:
%   childof(b, a)

%%%%%  WILL-Produced Tree #8 @ 12:29:20 4/20/17.  [Using 1,534,384 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( male(B) )
%   then if ( childof(B, A) )
%   | then return 0.2221919789288626;  // std dev = 0.012, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   | else return -0.07336957795551384;  // std dev = 0.000, 7.000 (wgt'ed) examples reached here.  /* #neg=7 */
%   else return -0.14425275664768974;  // std dev = 0.269, 6.000 (wgt'ed) examples reached here.  /* #neg=6 */


% Clauses:

father(A, B, 0.2221919789288626) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.07336957795551384) :- 
     male(B), 
     !. // Clause #2.

father(A, B, -0.14425275664768974) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_father(a, b, 0.2221919789288626) :-  /* #pos=5 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, a, -0.07336957795551384) :-  /* #neg=7 */ 
   male(a),
   !. // Flattened version of clause #2.

flattened_father(underscore, underscore, -0.14425275664768974) :-  /* #neg=6 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   male(b)
%   childof(b, a)
%   male(a)

%%%%%  WILL-Produced Tree #9 @ 12:29:20 4/20/17.  [Using 1,579,744 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( male(B) )
%   then if ( childof(B, A) )
%   | then return 0.18616949097499574;  // std dev = 0.011, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   | else return -0.06853493935234631;  // std dev = 0.000, 3.000 (wgt'ed) examples reached here.  /* #neg=3 */
%   else return -0.11236798078596133;  // std dev = 0.190, 4.000 (wgt'ed) examples reached here.  /* #neg=4 */


% Clauses:

father(A, B, 0.18616949097499574) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.06853493935234631) :- 
     male(B), 
     !. // Clause #2.

father(A, B, -0.11236798078596133) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_father(a, b, 0.18616949097499574) :-  /* #pos=5 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, a, -0.06853493935234631) :-  /* #neg=3 */ 
   male(a),
   !. // Flattened version of clause #2.

flattened_father(underscore, underscore, -0.11236798078596133) :-  /* #neg=4 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   male(b)
%   childof(b, a)
%   male(a)

%%%%%  WILL-Produced Tree #10 @ 12:29:20 4/20/17.  [Using 1,582,536 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( male(B) )
%   then if ( childof(B, A) )
%   | then return 0.15959587391203595;  // std dev = 0.009, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   | else return -0.06428708606827936;  // std dev = 0.000, 7.000 (wgt'ed) examples reached here.  /* #neg=7 */
%   else return -0.13355692649604128;  // std dev = 0.219, 5.000 (wgt'ed) examples reached here.  /* #neg=5 */


% Clauses:

father(A, B, 0.15959587391203595) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.06428708606827936) :- 
     male(B), 
     !. // Clause #2.

father(A, B, -0.13355692649604128) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_father(a, b, 0.15959587391203595) :-  /* #pos=5 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, a, -0.06428708606827936) :-  /* #neg=7 */ 
   male(a),
   !. // Flattened version of clause #2.

flattened_father(underscore, underscore, -0.13355692649604128) :-  /* #neg=5 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   male(b)
%   childof(b, a)
%   male(a)

%%%%%  WILL-Produced Tree Combined @ 12:29:20 4/20/17.  [Using 1,589,024 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( male(B) )
%   then if ( childof(B, A) )
%   | then return 0.1393362238574521;  // std dev = 0.008, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   | else return -0.06052657386545729;  // std dev = 0.000, 4.000 (wgt'ed) examples reached here.  /* #neg=4 */
%   else return -0.11116457184482802;  // std dev = 0.157, 3.000 (wgt'ed) examples reached here.  /* #neg=3 */


% Clauses:

father(A, B, 0.1393362238574521) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.06052657386545729) :- 
     male(B), 
     !. // Clause #2.

father(A, B, -0.11116457184482802) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_father(a, b, 0.1393362238574521) :-  /* #pos=5 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, a, -0.06052657386545729) :-  /* #neg=4 */ 
   male(a),
   !. // Flattened version of clause #2.

flattened_father(underscore, underscore, -0.11116457184482802) :-  /* #neg=3 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   male(b)
%   childof(b, a)
%   male(a)

%%%%%  WILL-Produced Tree #12 @ 12:29:20 4/20/17.  [Using 1,587,608 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( childof(B, A) )
%   then return 0.06770912165731625;  // std dev = 0.305, 6.000 (wgt'ed) examples reached here.  /* #neg=1 #pos=5 */
%   else return -0.05296186705689226;  // std dev = 0.021, 8.000 (wgt'ed) examples reached here.  /* #neg=8 */


% Clauses:

father(A, B, 0.06770912165731625) :- 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.05296186705689226) :- !. // Clause #2.


% The flattened versions of these clauses:

flattened_father(a, b, 0.06770912165731625) :-  /* #neg=1 #pos=5 */ 
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, underscore, -0.05296186705689226) :-  /* #neg=8 */ 
   !. // Flattened version of clause #2.


% The unique flattened literals:
%   childof(b, a)

%%%%%  WILL-Produced Tree #13 @ 12:29:20 4/20/17.  [Using 1,598,656 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( childof(B, A) )
%   then return 0.06164588825297674;  // std dev = 0.300, 6.000 (wgt'ed) examples reached here.  /* #neg=1 #pos=5 */
%   else return -0.048622181745366665;  // std dev = 0.021, 8.000 (wgt'ed) examples reached here.  /* #neg=8 */


% Clauses:

father(A, B, 0.06164588825297674) :- 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.048622181745366665) :- !. // Clause #2.


% The flattened versions of these clauses:

flattened_father(a, b, 0.06164588825297674) :-  /* #neg=1 #pos=5 */ 
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, underscore, -0.048622181745366665) :-  /* #neg=8 */ 
   !. // Flattened version of clause #2.


% The unique flattened literals:
%   childof(b, a)

%%%%%  WILL-Produced Tree #14 @ 12:29:20 4/20/17.  [Using 1,602,560 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( male(B) )
%   then if ( childof(B, A) )
%   | then return 0.11012385729661263;  // std dev = 0.007, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   | else return -0.05193906121445387;  // std dev = 1.86e-09, 6.000 (wgt'ed) examples reached here.  /* #neg=6 */
%   else return -0.13425025112309943;  // std dev = 0.241, 6.000 (wgt'ed) examples reached here.  /* #neg=6 */


% Clauses:

father(A, B, 0.11012385729661263) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.05193906121445387) :- 
     male(B), 
     !. // Clause #2.

father(A, B, -0.13425025112309943) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_father(a, b, 0.11012385729661263) :-  /* #pos=5 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, a, -0.05193906121445387) :-  /* #neg=6 */ 
   male(a),
   !. // Flattened version of clause #2.

flattened_father(underscore, underscore, -0.13425025112309943) :-  /* #neg=6 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   male(b)
%   childof(b, a)
%   male(a)

%%%%%  WILL-Produced Tree #15 @ 12:29:20 4/20/17.  [Using 1,616,544 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( male(B) )
%   then if ( childof(B, A) )
%   | then return 0.09978728806335155;  // std dev = 0.006, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   | else return -0.04944022371325105;  // std dev = 1.32e-09, 5.000 (wgt'ed) examples reached here.  /* #neg=5 */
%   else if ( siblingof(A, C) )
%   | then return -0.09265038293564554;  // std dev = 0.144, 3.000 (wgt'ed) examples reached here.  /* #neg=3 */
%   | else return -0.07827810765850796;  // std dev = 0.162, 4.000 (wgt'ed) examples reached here.  /* #neg=4 */


% Clauses:

father(A, B, 0.09978728806335155) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.04944022371325105) :- 
     male(B), 
     !. // Clause #2.

father(A, B, -0.09265038293564554) :- 
     siblingof(A, C), 
     !. // Clause #3.

father(A, B, -0.07827810765850796) :- !. // Clause #4.


% The flattened versions of these clauses:

flattened_father(a, b, 0.09978728806335155) :-  /* #pos=5 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, a, -0.04944022371325105) :-  /* #neg=5 */ 
   male(a),
   !. // Flattened version of clause #2.

flattened_father(a, underscore, -0.09265038293564554) :-  /* #neg=3 */ 
   siblingof(a, underscore),
   !. // Flattened version of clause #3.

flattened_father(underscore, underscore, -0.07827810765850796) :-  /* #neg=4 */ 
   !. // Flattened version of clause #4.


% The unique flattened literals:
%   siblingof(a, underscore)
%   male(b)
%   childof(b, a)
%   male(a)

%%%%%  WILL-Produced Tree #16 @ 12:29:20 4/20/17.  [Using 1,614,544 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( childof(B, A) )
%   then return 0.09117522491587086;  // std dev = 0.006, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   else return -0.04184215082459177;  // std dev = 0.018, 6.000 (wgt'ed) examples reached here.  /* #neg=6 */


% Clauses:

father(A, B, 0.09117522491587086) :- 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.04184215082459177) :- !. // Clause #2.


% The flattened versions of these clauses:

flattened_father(a, b, 0.09117522491587086) :-  /* #pos=5 */ 
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, underscore, -0.04184215082459177) :-  /* #neg=6 */ 
   !. // Flattened version of clause #2.


% The unique flattened literals:
%   childof(b, a)

%%%%%  WILL-Produced Tree #17 @ 12:29:20 4/20/17.  [Using 1,618,696 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( male(B) )
%   then if ( childof(B, A) )
%   | then return 0.08389713615126423;  // std dev = 0.005, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   | else return -0.04532253909207923;  // std dev = 0.000, 7.000 (wgt'ed) examples reached here.  /* #neg=7 */
%   else return -0.11945863884257633;  // std dev = 0.224, 6.000 (wgt'ed) examples reached here.  /* #neg=6 */


% Clauses:

father(A, B, 0.08389713615126423) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.04532253909207923) :- 
     male(B), 
     !. // Clause #2.

father(A, B, -0.11945863884257633) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_father(a, b, 0.08389713615126423) :-  /* #pos=5 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, a, -0.04532253909207923) :-  /* #neg=7 */ 
   male(a),
   !. // Flattened version of clause #2.

flattened_father(underscore, underscore, -0.11945863884257633) :-  /* #neg=6 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   male(b)
%   childof(b, a)
%   male(a)

%%%%%  WILL-Produced Tree #18 @ 12:29:20 4/20/17.  [Using 1,619,536 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( childof(B, A) )
%   then return 0.0776704157589156;  // std dev = 0.005, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   else return -0.03784022179922282;  // std dev = 0.027, 10.000 (wgt'ed) examples reached here.  /* #neg=10 */


% Clauses:

father(A, B, 0.0776704157589156) :- 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.03784022179922282) :- !. // Clause #2.


% The flattened versions of these clauses:

flattened_father(a, b, 0.0776704157589156) :-  /* #pos=5 */ 
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, underscore, -0.03784022179922282) :-  /* #neg=10 */ 
   !. // Flattened version of clause #2.


% The unique flattened literals:
%   childof(b, a)

%%%%%  WILL-Produced Tree #19 @ 12:29:20 4/20/17.  [Using 1,627,144 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( male(B) )
%   then if ( childof(B, A) )
%   | then return 0.07228598056555402;  // std dev = 0.005, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   | else return -0.041857246347676146;  // std dev = 1.32e-09, 7.000 (wgt'ed) examples reached here.  /* #neg=7 */
%   else return -0.09458600496276949;  // std dev = 0.191, 5.000 (wgt'ed) examples reached here.  /* #neg=5 */


% Clauses:

father(A, B, 0.07228598056555402) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.041857246347676146) :- 
     male(B), 
     !. // Clause #2.

father(A, B, -0.09458600496276949) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_father(a, b, 0.07228598056555402) :-  /* #pos=5 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, a, -0.041857246347676146) :-  /* #neg=7 */ 
   male(a),
   !. // Flattened version of clause #2.

flattened_father(underscore, underscore, -0.09458600496276949) :-  /* #neg=5 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   male(b)
%   childof(b, a)
%   male(a)

%%%%%  WILL-Produced Tree #20 @ 12:29:20 4/20/17.  [Using 1,631,440 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( male(B) )
%   then if ( childof(B, A) )
%   | then return 0.06758608756095401;  // std dev = 0.004, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   | else return -0.04021037422683108;  // std dev = 1.32e-09, 6.000 (wgt'ed) examples reached here.  /* #neg=6 */
%   else return -0.07836602909197538;  // std dev = 0.135, 3.000 (wgt'ed) examples reached here.  /* #neg=3 */


% Clauses:

father(A, B, 0.06758608756095401) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.04021037422683108) :- 
     male(B), 
     !. // Clause #2.

father(A, B, -0.07836602909197538) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_father(a, b, 0.06758608756095401) :-  /* #pos=5 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, a, -0.04021037422683108) :-  /* #neg=6 */ 
   male(a),
   !. // Flattened version of clause #2.

flattened_father(underscore, underscore, -0.07836602909197538) :-  /* #neg=3 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   male(b)
%   childof(b, a)
%   male(a)

%%%%%  WILL-Produced Tree #21 @ 12:29:21 4/20/17.  [Using 1,645,536 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( male(B) )
%   then if ( childof(B, A) )
%   | then return 0.06344964496439438;  // std dev = 0.004, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   | else return -0.038686887122541105;  // std dev = 0.000, 4.000 (wgt'ed) examples reached here.  /* #neg=4 */
%   else return -0.0622447903879185;  // std dev = 0.143, 4.000 (wgt'ed) examples reached here.  /* #neg=4 */


% Clauses:

father(A, B, 0.06344964496439438) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.038686887122541105) :- 
     male(B), 
     !. // Clause #2.

father(A, B, -0.0622447903879185) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_father(a, b, 0.06344964496439438) :-  /* #pos=5 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, a, -0.038686887122541105) :-  /* #neg=4 */ 
   male(a),
   !. // Flattened version of clause #2.

flattened_father(underscore, underscore, -0.0622447903879185) :-  /* #neg=4 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   male(b)
%   childof(b, a)
%   male(a)

%%%%%  WILL-Produced Tree #22 @ 12:29:21 4/20/17.  [Using 1,638,160 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( childof(B, A) )
%   then return 0.023001275665633366;  // std dev = 0.201, 6.000 (wgt'ed) examples reached here.  /* #neg=1 #pos=5 */
%   else return -0.037273514011315116;  // std dev = 0.000, 8.000 (wgt'ed) examples reached here.  /* #neg=8 */


% Clauses:

father(A, B, 0.023001275665633366) :- 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.037273514011315116) :- !. // Clause #2.


% The flattened versions of these clauses:

flattened_father(a, b, 0.023001275665633366) :-  /* #neg=1 #pos=5 */ 
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, underscore, -0.037273514011315116) :-  /* #neg=8 */ 
   !. // Flattened version of clause #2.


% The unique flattened literals:
%   childof(b, a)

%%%%%  WILL-Produced Tree #23 @ 12:29:21 4/20/17.  [Using 1,648,440 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( male(B) )
%   then if ( childof(B, A) )
%   | then return 0.05850247016484229;  // std dev = 0.004, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   | else return -0.03595881127812788;  // std dev = 0.000, 7.000 (wgt'ed) examples reached here.  /* #neg=7 */
%   else return -0.08025822413887045;  // std dev = 0.168, 5.000 (wgt'ed) examples reached here.  /* #neg=5 */


% Clauses:

father(A, B, 0.05850247016484229) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.03595881127812788) :- 
     male(B), 
     !. // Clause #2.

father(A, B, -0.08025822413887045) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_father(a, b, 0.05850247016484229) :-  /* #pos=5 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, a, -0.03595881127812788) :-  /* #neg=7 */ 
   male(a),
   !. // Flattened version of clause #2.

flattened_father(underscore, underscore, -0.08025822413887045) :-  /* #neg=5 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   male(b)
%   childof(b, a)
%   male(a)

%%%%%  WILL-Produced Tree #24 @ 12:29:21 4/20/17.  [Using 1,654,840 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( male(B) )
%   then if ( childof(B, A) )
%   | then return 0.055362325290497075;  // std dev = 0.004, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   | else return -0.03473285998440214;  // std dev = 0.000, 7.000 (wgt'ed) examples reached here.  /* #neg=7 */
%   else return -0.06400662629565888;  // std dev = 0.160, 6.000 (wgt'ed) examples reached here.  /* #neg=6 */


% Clauses:

father(A, B, 0.055362325290497075) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.03473285998440214) :- 
     male(B), 
     !. // Clause #2.

father(A, B, -0.06400662629565888) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_father(a, b, 0.055362325290497075) :-  /* #pos=5 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, a, -0.03473285998440214) :-  /* #neg=7 */ 
   male(a),
   !. // Flattened version of clause #2.

flattened_father(underscore, underscore, -0.06400662629565888) :-  /* #neg=6 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   male(b)
%   childof(b, a)
%   male(a)

%%%%%  WILL-Produced Tree #25 @ 12:29:21 4/20/17.  [Using 1,657,736 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( male(B) )
%   then if ( childof(B, A) )
%   | then return 0.05253742454387693;  // std dev = 0.003, 5.000 (wgt'ed) examples reached here.  /* #pos=5 */
%   | else return -0.03358702116846296;  // std dev = 0.000, 4.000 (wgt'ed) examples reached here.  /* #neg=4 */
%   else return -0.07220851584937413;  // std dev = 0.152, 5.000 (wgt'ed) examples reached here.  /* #neg=5 */


% Clauses:

father(A, B, 0.05253742454387693) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.03358702116846296) :- 
     male(B), 
     !. // Clause #2.

father(A, B, -0.07220851584937413) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_father(a, b, 0.05253742454387693) :-  /* #pos=5 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, a, -0.03358702116846296) :-  /* #neg=4 */ 
   male(a),
   !. // Flattened version of clause #2.

flattened_father(underscore, underscore, -0.07220851584937413) :-  /* #neg=5 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   male(b)
%   childof(b, a)
%   male(a)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%  Final call for computing score for father.  %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

stepLength_tree1(1.0).
stepLength_tree2(1.0).
stepLength_tree3(1.0).
stepLength_tree4(1.0).
stepLength_tree5(1.0).
stepLength_tree6(1.0).
stepLength_tree7(1.0).
stepLength_tree8(1.0).
stepLength_tree9(1.0).
stepLength_tree10(1.0).
stepLength_tree11(1.0).
stepLength_tree12(1.0).
stepLength_tree13(1.0).
stepLength_tree14(1.0).
stepLength_tree15(1.0).
stepLength_tree16(1.0).
stepLength_tree17(1.0).
stepLength_tree18(1.0).
stepLength_tree19(1.0).
stepLength_tree20(1.0).
stepLength_tree21(1.0).
stepLength_tree22(1.0).
stepLength_tree23(1.0).
stepLength_tree24(1.0).
stepLength_tree25(1.0).

logPrior(-1.8).
father(D, E, Total) :- // A general accessor. 
   father(D, E, 1000000, Total), !.
father(D, E, Total) :- waitHere("This should not fail", father(D, E, Total)).

father(D, E, TreesToUse, Total) :- // A tree-limited accessor (e.g., for tuning the number of trees to use).
   logPrior(LogPrior),
   getScore_father_tree1(D, E, TreesToUse, Total1),
   getScore_father_tree2(D, E, TreesToUse, Total2),
   getScore_father_tree3(D, E, TreesToUse, Total3),
   getScore_father_tree4(D, E, TreesToUse, Total4),
   getScore_father_tree5(D, E, TreesToUse, Total5),
   getScore_father_tree6(D, E, TreesToUse, Total6),
   getScore_father_tree7(D, E, TreesToUse, Total7),
   getScore_father_tree8(D, E, TreesToUse, Total8),
   getScore_father_tree9(D, E, TreesToUse, Total9),
   getScore_father_tree10(D, E, TreesToUse, Total10),
   getScore_father_tree11(D, E, TreesToUse, Total11),
   getScore_father_tree12(D, E, TreesToUse, Total12),
   getScore_father_tree13(D, E, TreesToUse, Total13),
   getScore_father_tree14(D, E, TreesToUse, Total14),
   getScore_father_tree15(D, E, TreesToUse, Total15),
   getScore_father_tree16(D, E, TreesToUse, Total16),
   getScore_father_tree17(D, E, TreesToUse, Total17),
   getScore_father_tree18(D, E, TreesToUse, Total18),
   getScore_father_tree19(D, E, TreesToUse, Total19),
   getScore_father_tree20(D, E, TreesToUse, Total20),
   getScore_father_tree21(D, E, TreesToUse, Total21),
   getScore_father_tree22(D, E, TreesToUse, Total22),
   getScore_father_tree23(D, E, TreesToUse, Total23),
   getScore_father_tree24(D, E, TreesToUse, Total24),
   getScore_father_tree25(D, E, TreesToUse, Total25),
   Total is LogPrior + Total1 + Total2 + Total3 + Total4 + Total5 + Total6 + Total7 + Total8 + Total9 + Total10 + Total11 + Total12 + Total13 + Total14 + Total15 + Total16 + Total17 + Total18 + Total19 + Total20 + Total21 + Total22 + Total23 + Total24 + Total25,
   !.
father(D, E, TreesToUse, Total) :- waitHere("This should not fail", father(D, E, TreesToUse, Total)).

getScore_father_tree1(D, E, TreesToUse, 0.0) :- 1 > TreesToUse, !.
getScore_father_tree1(D, E, TreesToUse, Total1) :- father_tree1(D, E, Total), stepLength_tree1(StepLen), Total1 is Total * StepLen.

getScore_father_tree2(D, E, TreesToUse, 0.0) :- 2 > TreesToUse, !.
getScore_father_tree2(D, E, TreesToUse, Total2) :- father_tree2(D, E, Total), stepLength_tree2(StepLen), Total2 is Total * StepLen.

getScore_father_tree3(D, E, TreesToUse, 0.0) :- 3 > TreesToUse, !.
getScore_father_tree3(D, E, TreesToUse, Total3) :- father_tree3(D, E, Total), stepLength_tree3(StepLen), Total3 is Total * StepLen.

getScore_father_tree4(D, E, TreesToUse, 0.0) :- 4 > TreesToUse, !.
getScore_father_tree4(D, E, TreesToUse, Total4) :- father_tree4(D, E, Total), stepLength_tree4(StepLen), Total4 is Total * StepLen.

getScore_father_tree5(D, E, TreesToUse, 0.0) :- 5 > TreesToUse, !.
getScore_father_tree5(D, E, TreesToUse, Total5) :- father_tree5(D, E, Total), stepLength_tree5(StepLen), Total5 is Total * StepLen.

getScore_father_tree6(D, E, TreesToUse, 0.0) :- 6 > TreesToUse, !.
getScore_father_tree6(D, E, TreesToUse, Total6) :- father_tree6(D, E, Total), stepLength_tree6(StepLen), Total6 is Total * StepLen.

getScore_father_tree7(D, E, TreesToUse, 0.0) :- 7 > TreesToUse, !.
getScore_father_tree7(D, E, TreesToUse, Total7) :- father_tree7(D, E, Total), stepLength_tree7(StepLen), Total7 is Total * StepLen.

getScore_father_tree8(D, E, TreesToUse, 0.0) :- 8 > TreesToUse, !.
getScore_father_tree8(D, E, TreesToUse, Total8) :- father_tree8(D, E, Total), stepLength_tree8(StepLen), Total8 is Total * StepLen.

getScore_father_tree9(D, E, TreesToUse, 0.0) :- 9 > TreesToUse, !.
getScore_father_tree9(D, E, TreesToUse, Total9) :- father_tree9(D, E, Total), stepLength_tree9(StepLen), Total9 is Total * StepLen.

getScore_father_tree10(D, E, TreesToUse, 0.0) :- 10 > TreesToUse, !.
getScore_father_tree10(D, E, TreesToUse, Total10) :- father_tree10(D, E, Total), stepLength_tree10(StepLen), Total10 is Total * StepLen.

getScore_father_tree11(D, E, TreesToUse, 0.0) :- 11 > TreesToUse, !.
getScore_father_tree11(D, E, TreesToUse, Total11) :- father_tree11(D, E, Total), stepLength_tree11(StepLen), Total11 is Total * StepLen.

getScore_father_tree12(D, E, TreesToUse, 0.0) :- 12 > TreesToUse, !.
getScore_father_tree12(D, E, TreesToUse, Total12) :- father_tree12(D, E, Total), stepLength_tree12(StepLen), Total12 is Total * StepLen.

getScore_father_tree13(D, E, TreesToUse, 0.0) :- 13 > TreesToUse, !.
getScore_father_tree13(D, E, TreesToUse, Total13) :- father_tree13(D, E, Total), stepLength_tree13(StepLen), Total13 is Total * StepLen.

getScore_father_tree14(D, E, TreesToUse, 0.0) :- 14 > TreesToUse, !.
getScore_father_tree14(D, E, TreesToUse, Total14) :- father_tree14(D, E, Total), stepLength_tree14(StepLen), Total14 is Total * StepLen.

getScore_father_tree15(D, E, TreesToUse, 0.0) :- 15 > TreesToUse, !.
getScore_father_tree15(D, E, TreesToUse, Total15) :- father_tree15(D, E, Total), stepLength_tree15(StepLen), Total15 is Total * StepLen.

getScore_father_tree16(D, E, TreesToUse, 0.0) :- 16 > TreesToUse, !.
getScore_father_tree16(D, E, TreesToUse, Total16) :- father_tree16(D, E, Total), stepLength_tree16(StepLen), Total16 is Total * StepLen.

getScore_father_tree17(D, E, TreesToUse, 0.0) :- 17 > TreesToUse, !.
getScore_father_tree17(D, E, TreesToUse, Total17) :- father_tree17(D, E, Total), stepLength_tree17(StepLen), Total17 is Total * StepLen.

getScore_father_tree18(D, E, TreesToUse, 0.0) :- 18 > TreesToUse, !.
getScore_father_tree18(D, E, TreesToUse, Total18) :- father_tree18(D, E, Total), stepLength_tree18(StepLen), Total18 is Total * StepLen.

getScore_father_tree19(D, E, TreesToUse, 0.0) :- 19 > TreesToUse, !.
getScore_father_tree19(D, E, TreesToUse, Total19) :- father_tree19(D, E, Total), stepLength_tree19(StepLen), Total19 is Total * StepLen.

getScore_father_tree20(D, E, TreesToUse, 0.0) :- 20 > TreesToUse, !.
getScore_father_tree20(D, E, TreesToUse, Total20) :- father_tree20(D, E, Total), stepLength_tree20(StepLen), Total20 is Total * StepLen.

getScore_father_tree21(D, E, TreesToUse, 0.0) :- 21 > TreesToUse, !.
getScore_father_tree21(D, E, TreesToUse, Total21) :- father_tree21(D, E, Total), stepLength_tree21(StepLen), Total21 is Total * StepLen.

getScore_father_tree22(D, E, TreesToUse, 0.0) :- 22 > TreesToUse, !.
getScore_father_tree22(D, E, TreesToUse, Total22) :- father_tree22(D, E, Total), stepLength_tree22(StepLen), Total22 is Total * StepLen.

getScore_father_tree23(D, E, TreesToUse, 0.0) :- 23 > TreesToUse, !.
getScore_father_tree23(D, E, TreesToUse, Total23) :- father_tree23(D, E, Total), stepLength_tree23(StepLen), Total23 is Total * StepLen.

getScore_father_tree24(D, E, TreesToUse, 0.0) :- 24 > TreesToUse, !.
getScore_father_tree24(D, E, TreesToUse, Total24) :- father_tree24(D, E, Total), stepLength_tree24(StepLen), Total24 is Total * StepLen.

getScore_father_tree25(D, E, TreesToUse, 0.0) :- 25 > TreesToUse, !.
getScore_father_tree25(D, E, TreesToUse, Total25) :- father_tree25(D, E, Total), stepLength_tree25(StepLen), Total25 is Total * StepLen.

flattenedLiteralsInThisSetOfTrees(father, 4, [
   siblingof(a, underscore),
   childof(b, a),
   male(b),
   male(a)]).

%%%%%  WILL-Produced Tree Combined @ 12:29:21 4/20/17.  [Using 1,715,832 memory cells.]  %%%%%

% FOR father(A, B):
%   if ( childof(B, A) )
%   then if ( male(B) )
%   | then if ( siblingof(A, C) )
%   | | then return 5.435330771522146;  // std dev = 0.000, 75.000 (wgt'ed) examples reached here.  /* #pos=75 */
%   | | else return 5.579705719819889;  // std dev = 0.000, 50.000 (wgt'ed) examples reached here.  /* #pos=50 */
%   | else return -2.7255748144660648;  // std dev = 2.06e-07, 12.000 (wgt'ed) examples reached here.  /* #neg=12 */
%   else if ( male(B) )
%   | then if ( siblingof(A, D) )
%   | | then if ( siblingof(B, D) )
%   | | | then return -0.8001049013171296;  // std dev = 0.445, 23.000 (wgt'ed) examples reached here.  /* #neg=23 */
%   | | | else return -0.7481065746149289;  // std dev = 0.000, 10.000 (wgt'ed) examples reached here.  /* #neg=10 */
%   | | else return -1.0379652169574174;  // std dev = 0.023, 28.000 (wgt'ed) examples reached here.  /* #neg=28 */
%   | else if ( siblingof(A, E) )
%   | | then return -0.7903715073366225;  // std dev = 0.145, 25.000 (wgt'ed) examples reached here.  /* #neg=25 */
%   | | else if ( male(A) )
%   | | | then return -0.6430103027577033;  // std dev = 0.000, 11.000 (wgt'ed) examples reached here.  /* #neg=11 */
%   | | | else return -0.7771919455993804;  // std dev = 0.442, 27.000 (wgt'ed) examples reached here.  /* #neg=27 */


% Clauses:

father(A, B, 5.435330771522146) :- 
     childof(B, A), 
     male(B), 
     siblingof(A, C), 
     !. // Clause #1.

father(A, B, 5.579705719819889) :- 
     childof(B, A), 
     male(B), 
     !. // Clause #2.

father(A, B, -2.7255748144660648) :- 
     childof(B, A), 
     !. // Clause #3.

father(A, B, -0.8001049013171296) :- 
     male(B), 
     siblingof(A, C), 
     siblingof(B, C), 
     !. // Clause #4.

father(A, B, -0.7481065746149289) :- 
     male(B), 
     siblingof(A, C), 
     !. // Clause #5.

father(A, B, -1.0379652169574174) :- 
     male(B), 
     !. // Clause #6.

father(A, B, -0.7903715073366225) :- 
     siblingof(A, C), 
     !. // Clause #7.

father(A, B, -0.6430103027577033) :- 
     male(A), 
     !. // Clause #8.

father(A, B, -0.7771919455993804) :- !. // Clause #9.


% The flattened versions of these clauses:

flattened_father(a, b, 5.435330771522146) :-  /* #pos=75 */ 
   childof(b, a),
   male(b),
   siblingof(a, underscore),
   !. // Flattened version of clause #1.

flattened_father(a, b, 5.579705719819889) :-  /* #pos=50 */ 
   childof(b, a),
   male(b),
   !. // Flattened version of clause #2.

flattened_father(a, b, -2.7255748144660648) :-  /* #neg=12 */ 
   childof(b, a),
   !. // Flattened version of clause #3.

flattened_father(a, b, -0.8001049013171296) :-  /* #neg=23 */ 
   male(b),
   siblingof(a, uniqueVar1),
   siblingof(b, uniqueVar1),
   !. // Flattened version of clause #4.

flattened_father(a, b, -0.7481065746149289) :-  /* #neg=10 */ 
   male(b),
   siblingof(a, underscore),
   !. // Flattened version of clause #5.

flattened_father(underscore, a, -1.0379652169574174) :-  /* #neg=28 */ 
   male(a),
   !. // Flattened version of clause #6.

flattened_father(a, underscore, -0.7903715073366225) :-  /* #neg=25 */ 
   siblingof(a, underscore),
   !. // Flattened version of clause #7.

flattened_father(a, underscore, -0.6430103027577033) :-  /* #neg=11 */ 
   male(a),
   !. // Flattened version of clause #8.

flattened_father(underscore, underscore, -0.7771919455993804) :-  /* #neg=27 */ 
   !. // Flattened version of clause #9.


% The unique flattened literals:
%   siblingof(a, underscore)
%   siblingof(a, uniqueVar1)
%   siblingof(b, uniqueVar1)
%   childof(b, a)
%   male(b)
%   male(a)
